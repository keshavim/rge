use std::sync::mpsc::Receiver;

use glfw::{Callback, Context, Error, WindowEvent, WindowHint};

use crate::log::rge_engine_error;

use super::events::*;

//todo need to make all the public stuff private and acessed form methods
pub struct WindowData {
    title: String,
    pub width: u32,
    pub height: u32,
    vsync: bool,
}

// window/mod.rs
pub struct WindowManager {
    pub data: WindowData,
    glfw: glfw::Glfw,
    pub window: glfw::Window,
    events: Receiver<(f64, glfw::WindowEvent)>,
}

impl WindowManager {
    pub fn new(title: &str, width: u32, height: u32) -> Self {
        let mut glfw = glfw::init(glfw::FAIL_ON_ERRORS).unwrap();

        // Set all window hints
        glfw.window_hint(WindowHint::ContextVersion(4, 5));
        glfw.window_hint(WindowHint::OpenGlProfile(glfw::OpenGlProfileHint::Core));
        glfw.window_hint(WindowHint::OpenGlForwardCompat(true));
        glfw.window_hint(WindowHint::DoubleBuffer(true));
        glfw.window_hint(WindowHint::Samples(Some(4))); // MSAA
        glfw.window_hint(WindowHint::OpenGlDebugContext(cfg!(debug_assertions)));

        // Set a custom error callback
        // In your initialization code
        glfw.set_error_callback(Some(Callback {
            f: glfw_error_callback,
            data: (),
        }));
        let (mut window, events) = glfw
            .create_window(width, height, title, glfw::WindowMode::Windowed)
            .expect("Failed to create GLFW window");

        window.make_current();
        window.set_all_polling(true);
        glfw.set_swap_interval(glfw::SwapInterval::Sync(1));

        let data = WindowData {
            title: title.to_string(),
            width,
            height,
            vsync: true,
        };

        Self {
            data,
            glfw,
            window,
            events,
        }
    }

    pub fn handle_events(&mut self) -> Option<RGEvent> {
    for (_, event) in glfw::flush_messages(&self.events) {
        match event {
            glfw::WindowEvent::Key(key, _, action, _) => match action {
                glfw::Action::Press => {
                    return Some(RGEvent::KeyPressed(KeyPressedEvent::new(key, false)));
                }
                glfw::Action::Release => {
                    return Some(RGEvent::KeyReleased(KeyReleasedEvent::new(key)));
                }
                glfw::Action::Repeat => {
                    return Some(RGEvent::KeyPressed(KeyPressedEvent::new(key, true)));
                }
            },
            _ => continue, // Skip unsupported events
        }
    }
    None // Return None if no events are found
}
    }
    //glfw::WindowEvent::Focus(focused) => {
    //    if focused {
    //        Some(RGEvent::WindowFocus(WindowFocusEvent::new(false)))
    //    } else {
    //        Some(RGEvent::WindowLostFocus(WindowLostFocusEvent::new(false)))
    //    }
    //}
    //glfw::WindowEvent::Pos(x, y) => {
    //    Some(RGEvent::WindowMoved(WindowMovedEvent::new(false, x, y)))
    //}
    ////glfw::WindowEvent::Size(width, height) => Some(RGEvent::WindowResize(
    ////    WindowResizeEvent::new(false, width, height),
    ////)),
    ////glfw::WindowEvent::Key(key, scode, action, mods) => {
    ////    Some(RGEvent::KeyPressed(KeyPressedEvent::new(
    ////        false, key, ,
    ////    )))
    ////}
    ////glfw::WindowEvent::Key(key, scode, action, mods) => {
    ////    Some(RGEvent::KeyReleased(KeyReleasedEvent::new(false, key)))
    ////}
    ////glfw::WindowEvent::MouseButton(button, action, mods) => Some(
    ////    RGEvent::MouseButtonPressed(MouseButtonPressedEvent::new(false, button)),
    ////),
    ////glfw::WindowEvent::MouseButton(button, action, mods) => Some(
    ////    RGEvent::MouseButtonReleased(MouseButtonReleasedEvent::new(false, button)),
    ////),
    //glfw::WindowEvent::CursorPos(x, y) => {
    //    Some(RGEvent::MouseMoved(MouseMovedEvent::new(false, x, y)))
    //}
    //glfw::WindowEvent::Scroll(x_offset, y_offset) => Some(RGEvent::MouseScrolled(
    //    MouseScrolledEvent::new(false, x_offset, y_offset),
    //)),

    pub fn poll_events<F: FnMut(glfw::WindowEvent)>(&mut self, mut callback: F) {
        self.glfw.poll_events();
        for (_, event) in glfw::flush_messages(&self.events) {
            callback(event);
        }
    }

    pub fn swap_buffers(&mut self) {
        self.window.swap_buffers();
    }

    pub fn get_glfw(&self) -> &glfw::Glfw {
        &self.glfw
    }

    pub fn native_window(&mut self) -> &mut glfw::Window {
        &mut self.window
    }
    pub fn is_vsync(&self) -> bool {
        self.data.vsync
    }
    pub fn set_vsync(&mut self, b: bool) {
        self.data.vsync = b;
    }
}

fn glfw_error_callback<'a>(error: Error, description: String, _context: &'a ()) {
    rge_engine_error!("GLFW Error {:?}: {}", error, description);
}
